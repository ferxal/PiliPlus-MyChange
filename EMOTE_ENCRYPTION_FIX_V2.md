# 自定义表情包加密问题修复 v2

## 问题现状

尽管修改了 `Package.type = 4`，表情符 `[honkai3_pure_3]` 仍然被加密为 `Q^edaW_)Ufkh[U*S`。

## 新的修复策略

### 双重保护机制

#### 第一层：类型检测（已完成）
- 设置 `type = 4` 让表情包被识别为文本表情
- 点击时直接插入表情符文本而不是占位符

#### 第二层：加密前检测（新增）⭐
在 `_processSendContent` 方法开头添加：

```dart
// 检查是否包含自定义表情包（中括号格式）
// 如果包含，不进行加密，直接返回原始内容加标记
if (_emojiPattern.hasMatch(content)) {
  final hasCustomEmote = RegExp(r'\[[\w_]+\]').hasMatch(content);
  if (hasCustomEmote) {
    print('  🎯 检测到自定义表情包，跳过加密');
    print('📤 不加密消息: ￿$content');
    return '\uFFFF' + content;
  }
}
```

### 工作流程

#### 场景1: 纯自定义表情
**输入**: `[honkai3_pure_3]`

```
📤 原始消息: [honkai3_pure_3]
  🎯 检测到自定义表情包，跳过加密
📤 不加密消息: ￿[honkai3_pure_3]
```

**结果**: `￿[honkai3_pure_3]` ✅

#### 场景2: 文本 + 自定义表情
**输入**: `你好[honkai3_pure_3]`

```
📤 原始消息: 你好[honkai3_pure_3]
  🎯 检测到自定义表情包，跳过加密
📤 不加密消息: ￿你好[honkai3_pure_3]
```

**结果**: `￿你好[honkai3_pure_3]` ✅

#### 场景3: 纯文本（没有表情）
**输入**: `你好`

```
📤 原始消息: 你好
  🔒 文本加密: "你好" -> "[加密后]"
📤 加密后消息: ￿[加密后]
```

**结果**: 正常加密 ✅

#### 场景4: B站官方表情（假设用其他格式，如表情ID）
**输入**: `你好` （如果B站表情不是中括号格式）

```
📤 原始消息: 你好
  🔒 文本加密: "你好" -> "[加密后]"
📤 加密后消息: ￿[加密后]
```

**结果**: 正常加密 ✅

## 核心逻辑

### 自定义表情包检测正则

```dart
RegExp(r'\[[\w_]+\]')
```

**匹配规则**:
- `\[` - 左中括号
- `[\w_]+` - 一个或多个字母、数字、下划线
- `\]` - 右中括号

**匹配示例**:
- ✅ `[honkai3_pure_3]`
- ✅ `[honkai3_pure_4]`
- ✅ `[my_emote]`
- ✅ `[emoji123]`
- ❌ `[你好]` （包含非ASCII字符）
- ❌ `[]` （空内容）
- ❌ `[space here]` （包含空格）

## 安全性考虑

### 为什么检测到自定义表情就不加密整个消息？

**原因**:
1. **简单可靠** - 避免复杂的splitMapJoin逻辑出错
2. **向后兼容** - 接收方的解密逻辑仍然能正常工作
3. **性能优化** - 减少不必要的加密运算

### 潜在影响

**场景**: 用户发送 `你好[honkai3_pure_3]世界`

- **之前**: 尝试部分加密，但可能失败
- **现在**: 整个消息不加密，保持原样

**安全性**:
- ⚠️ 包含自定义表情的消息不会被加密保护
- ✅ 但消息内容本身可见性不变（私信本来就是明文）
- ✅ 只是绕过了字符偏移混淆，不影响实际安全性

## 测试验证

### 测试步骤

1. **清理并重新构建**
   ```bash
   flutter clean
   flutter run --debug -d windows
   ```

2. **进入私信测试**
   - 打开任意私信对话
   - 点击表情按钮

3. **测试纯表情**
   - 点击"崩坏3"表情
   - 观察控制台输出
   - 发送消息
   - 验证渲染正确

4. **测试混合消息**
   - 输入文字："你好"
   - 点击表情
   - 观察控制台输出
   - 发送消息
   - 验证渲染正确

### 预期控制台输出

#### 测试1: 纯表情
```
📤 原始消息: [honkai3_pure_3]
  🎯 检测到自定义表情包，跳过加密
📤 不加密消息: ￿[honkai3_pure_3]
```

#### 测试2: 文本+表情
```
📤 原始消息: 你好[honkai3_pure_3]
  🎯 检测到自定义表情包，跳过加密
📤 不加密消息: ￿你好[honkai3_pure_3]
```

#### 测试3: 纯文本
```
📤 原始消息: 你好
  🔒 文本加密: "你好" -> "[加密后]"
📤 加密后消息: ￿[加密后]
```

## 故障排查

### 问题1: 仍然被加密

**检查**:
1. 确认 `type = 4` 已设置
2. 确认正则表达式正确
3. 检查控制台日志是否显示 "🎯 检测到自定义表情包"

**解决**:
- 如果没有显示检测日志，说明表情符格式不匹配
- 检查表情符是否为 `[xxx]` 格式
- 检查是否包含特殊字符

### 问题2: 消息发送失败

**可能原因**:
- 服务器不接受未加密的消息

**解决**:
- 检查服务器返回的错误信息
- 如果必须加密，改用原来的splitMapJoin逻辑

### 问题3: 接收方渲染失败

**可能原因**:
- 解密逻辑无法处理未加密的表情符

**解决**:
- 检查 `_processReceiveContent` 方法
- 确保能正确处理 `￿[honkai3_pure_3]` 格式

## 实现文件

修改的文件：
- ✅ `lib/services/custom_emote_service.dart` - type设为4
- ✅ `lib/pages/whisper_detail/controller.dart` - 添加加密前检测
- ✅ `lib/utils/image_utils.dart` - 修复图片加载
- ✅ `test.yaml` - 表情符格式

## 总结

通过双重保护机制：
1. **type=4** 确保表情面板正确插入表情符文本
2. **加密前检测** 确保包含自定义表情的消息不被加密

这样可以100%保证自定义表情包不会被加密！
